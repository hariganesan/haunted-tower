package {		import flash.display.MovieClip;	import flash.display.Sprite;	import flash.utils.Timer;	import flash.ui.Mouse;		import flash.events.Event;	import flash.events.MouseEvent;	import flash.events.TimerEvent;		import flash.text.TextField;	import flash.text.TextFormat;	import fl.controls.Button;		public final class Main extends MovieClip {				// user game state		private var gameState:int = GameState.INACTIVE;		private var currentLevel:int = 3;		private var currentScore:int = 0;		private var currentMoney:int = 100;		private var currentHealth:int = 10;		//private var currentSpeed:int = 1;				// attackers and timer		private var timerDelay:int = 2000; // default delay (in ms)		private var attackerTimer:Timer;		private var attackerCount:int = 0;		private var attackersRemaining:int;		private var attackerList:Vector.<Attacker> = new Vector.<Attacker>();				// defenders and projectiles		private var projectileCount:int = 0;				// on-screen static elements		private var horizon:LineBlack = new LineBlack();		private var score:TextField = new TextField();		private var money:TextField = new TextField();		private var health:TextField = new TextField();		private var healthFormat:TextFormat = new TextFormat();		private var msgGameOver:TextField = new TextField();				private var cursor:Sprite = new Sprite();				// buttons		private var bDefender:Button = new Button();				public function Main() {			// constructor code			Init();			gameState = GameState.ACTIVE;						trace("init'd main");			addEventListener(MouseEvent.CLICK, function() { trace("click"); });		}				private function Init():void {			stage.frameRate = 30;						// TODO: format text fields						// create score			score.text = 'Score: ' + currentScore;			score.x = stage.stageWidth * 0.01;			score.y = stage.stageHeight * 0.95;			addChild(score);						// create money			money.text = '$' + currentMoney;			money.x = stage.stageWidth * 0.2;			money.y = score.y;			addChild(money);						// create health			health.text = currentHealth.toString();			healthFormat.color = 0xFF0000;			health.setTextFormat(healthFormat);			health.x = stage.stageWidth * 0.9;			health.y = score.y;			addChild(health);						// create defender button(s)			bDefender.label = "Add Defender";			bDefender.toggle = true;			bDefender.move(stage.stageWidth * 0.05, stage.stageHeight * 0.05);			bDefender.addEventListener(MouseEvent.CLICK, deployDefender);			addChild(bDefender);						// create custom cursor(s)			cursor.graphics.beginFill(0x000000);			cursor.graphics.drawCircle(0, 0, 20);			cursor.graphics.endFill();						// create line for horizon			horizon.x = 0;			horizon.y = stage.stageHeight * 0.9;			addChild(horizon);						// begin first level			attackersRemaining = currentLevel * 10;			attackerTimer = new Timer(timerDelay, attackersRemaining);			attackerTimer.addEventListener(TimerEvent.TIMER, createAttacker);			attackerTimer.start();		}				private function focus(m:MouseEvent):void {			stage.focus = this;		}				// ATTACKERS				private function createAttacker(t:TimerEvent):void {			var a:Attacker = 				new Attacker(this, attackerCount + 1, 3, 3, currentLevel);			attackerList.push(a);			attackerCount++;			attackersRemaining--; // is timer dynamic (does var change for timer?)		}				public function destroyAttacker(id:int):void {			attackerList[id] = null;			attackerCount--;		}				// checks collisions between a projectile and n attackers		public function checkCollisions(p:Projectile):Boolean {			for (var i:int = 0; i < attackerList.length; i++) {				if (p.hitTestObject(attackerList[i])) {					attackerList[i].addDamage(p.getStrength());					return true;				}			}						return false;		}				public function addDamage(strength:int):void {			currentHealth -= strength;						if (currentHealth <= 0) {				currentHealth = 0;				health.text = currentHealth.toString();				endGame();			}						health.text = currentHealth.toString();			health.setTextFormat(healthFormat); // why is this necessary?		}				// DEFENDERS				public function deployDefender(e:MouseEvent) {			// change mouse cursor			stage.addEventListener(MouseEvent.MOUSE_MOVE, redrawCursor);			Mouse.hide();			addChild(cursor);						// allow creation			bDefender.label = "Cancel";			bDefender.toggle = true;			bDefender.removeEventListener(MouseEvent.CLICK, deployDefender);			bDefender.addEventListener(MouseEvent.CLICK, cancelDeployDefender);			bDefender.validateNow();			stage.addEventListener(MouseEvent.CLICK, createDefender);		}				public function cancelDeployDefender(e:MouseEvent) {			// change back mouse cursor			stage.removeEventListener(MouseEvent.MOUSE_MOVE, redrawCursor);			Mouse.show();			removeChild(cursor);						// disallow creation, reallow deployment			bDefender.label = "Add Defender";			bDefender.toggle = true;			bDefender.removeEventListener(MouseEvent.CLICK, cancelDeployDefender);			bDefender.addEventListener(MouseEvent.CLICK, deployDefender);			bDefender.validateNow();			stage.removeEventListener(MouseEvent.CLICK, createDefender);		}				public function redrawCursor(e:MouseEvent) {			cursor.x = e.stageX;			cursor.y = e.stageY;		}				public function createDefender(e:MouseEvent) {			if (currentMoney >= 10) {				currentMoney -= 10;				money.text = '$' + currentMoney;								// create defender here			}						cancelDeployDefender(e);		}				// CLEAN UP				public function endGame():void {			attackerTimer.stop();						gameState = GameState.INACTIVE;			msgGameOver = new TextField();			msgGameOver.text = "Game Over";			msgGameOver.x = stage.stageWidth * 0.45;			msgGameOver.y = stage.stageHeight/2;			addChild(msgGameOver);		}				// accessor functions				public function getHorizon():LineBlack {			return horizon;		}				public function getGameState():int {			return gameState;		}				public function getProjectileCount():int {			return projectileCount;		}				public function addProjectile(proj:Projectile):int {			// add projectile to vector			projectileCount++;						// return next available id?			return 0;		}				public function removeProjectile(proj:Projectile):void {			projectileCount--;		}	}	}